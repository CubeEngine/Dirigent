![Dirigent](https://github.com/CubeEngine/Dirigent/blob/master/Dirigent.png?raw=true)
=================

[![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.cubeengine/dirigent/badge.svg?style=flat)](https://maven-badges.herokuapp.com/maven-central/org.cubeengine/dirigent)
[![Build Status](https://travis-ci.org/CubeEngine/Dirigent.svg?branch=master)](https://travis-ci.org/CubeEngine/Dirigent)

The Dirigent project is a compact formatting framework. It can be used to place message parameters into a message elegantly. This can be done by specifying so called macros within a message which will be replaced by the correct input parameters in the desired way. Therefore it can be used in conjunction with translated messages perfectly.

# Macro

A macro is a special sequence of letters which is replaced with an input parameter from Dirigent using a Formatter. It must be placed within a string message. Furthermore it's possible to specify more than one macro in a single message. In this context macros follow the syntax:

 ```{[[<position>:]type[#<label>][:<args>]]}``` or just ```{[position]}```
 
Ensuing from the syntax here are the possibilities:

1. Using default macros: "Hello {} {}, how are you doing?"; A default macro only uses a default formatter which can be specified with the Dirigent constructor. It doesn't provide any contextual information. The input parameters are inserted into the message in the same order as they're specified.
2. Using indexed macros: "Hello {0} {1}, how are you doing?"; When translating a message with multiple arguments the translator might have to change the order in which the arguments are. Different languages have a different order of the parameter occurrences often. Therefore it must be possible to specify the position of the parameter in the input parameter list. Keep in mind positions do start with 0 not with 1! Simple indexed parameters use the default formatter as well.
3. Using a different formatter: "Hello {name}, how are you doing?"; In this example the macro value will be generated by a formatter handling the name `name`. The formatter can do whatever it wants. To provide locale based parameter values it gets a compose context. This also contains additional information. But a formatter just formats a single input parameter.
4. Using a different formatter and an index: "Hello {0:name}, how are you doing?"; It's also possible to add an optional position to the formatter. This has the same effect as for the default macro.
5. Using a formatter with special arguments: "Date: {date:format=yyyy-MM-dd}"; A formatter can get different arguments to do the job. Every argument is split with a `:`. There are two types of different arguments. A parameter argument maps a argument name to a value like the example illustrates it. A value argument only has a value. This could be a flag.
6. Providing additional information: "Hello {0:name#name of the user:some-argument}, how are you doing?"; A label is a kind of contextual information for the localizer. This won't be available within the code and only helps the localizer to understand the meaning of the parameter. A label can be used without specifying an argument too.

The label as well as the arguments are allowed to contain any character except `:`, `}` and `\` which have to be escaped using `\`.

# Process

Here describe the internal process of the AbstractDirigent class a little
- show main methods (with context and empty context)
- Split messages into tokens Text, Macro 
- convert tokens to components: Text, ResolvedMacro (Formatter + PostProcessors), UnresolvedMacro (two types)
- composing the components part of sub implementations (like BuilderDirigent which is described later)

# Context

what is the context, what can it be used for, where is it important?
what kind of properties are available already? Contexts class

# Formatter

explain formatter, default formatter for default macro
show abstractformatter und reflectedformatter for easy usage

You can register a Macro with multiple "type-names" for a single class or multiple or you could override the isApplicable method to do your own checks.
A Macro will accept multiple arguments separated by `:` which will be provided in the MacroContext.  
It is also possible to map arguments using `<key>=<value>`.

Example DateFormatter:

Setup:
First Create a new Dirigent and register the formatter.  
```this.dirigent = new StringBuilderDirigent()```    
```this.dirigent.registerFormatter(new DateFormatter())```  
Now the DateFormatter is ready to use, you can also specify the format to use.
```this.dirigent.compose("Today is {date:format=yyyy-MM-dd}", new Date())```  
The Dirigent will now search for any registered Formatter for "type" accepting a Date.
The DateFormatter will use format argument to create a SimpleDateFormatter with the specified format and then replace the whole macro with the formatted Date.  
   

## Available Formatters

dirigent provides a few formatters already; They all provide default macro names, but they can be changed with the constructor

### StringFormatter

explanation

flags: uppercase, lowercase
context-properties: none
default-names: blub

### NumberFormatter

explanation

- flags: integer, currency, percent
- params: format
- context-properties: LOCALE, CURRENCY
- default-names: blub

#### IntegerFormatter

starts in integer mode by default

- default-names: blub

#### CurrencyFormatter

starts in currency mode by default

- default-names: blub

#### PercentFormatter

starts in percent mode by default

- default-names: blub

### DateTimeFormatter

explanation

- flags: short, medium, long, full
- params: format, date, time
- context-properties: LOCALE, TIMEZONE
- default-names: blub

#### DateFormatter

explanation

- default-names: blub

#### TimeFormatter

explanation

- default-names: blub

### StaticTextFormatter

explanation

- args: text
- params: none
- context-properties: none
- default-names: text

# Post Processors

what is it? How can they be used? dirigent + formatter

# BuilderDirigent

composes a message with a builder

StaticBuilderDirigent

how to control components, how to handle own components from own formatter
