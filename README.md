![Dirigent](https://github.com/CubeEngine/Dirigent/blob/master/Dirigent.png?raw=true)
=================

[![Maven Central](https://maven-badges.herokuapp.com/maven-central/org.cubeengine/dirigent/badge.svg?style=flat)](https://maven-badges.herokuapp.com/maven-central/org.cubeengine/dirigent)
[![Build Status](https://travis-ci.org/CubeEngine/Dirigent.svg?branch=master)](https://travis-ci.org/CubeEngine/Dirigent)

The Dirigent project is a compact formatting framework. It can be used to place message parameters into a message elegantly. This can be done by specifying so called macros within a message which will be replaced by the correct input parameters in the desired way. Therefore it can be used in conjunction with translated messages perfectly.

# Macro

A macro is a special sequence of letters which is replaced with an input parameter from Dirigent using a Formatter. It must be placed within a string message. Furthermore it's possible to specify more than one macro in a single message. In this context macros follow the syntax:

 ```{[[<position>:]type[#<label>][:<args>]]}``` or just ```{[position]}```
 
Ensuing from the syntax here are the possibilities:

1. Using default macros: "Hello {} {}, how are you doing?"; A default macro only uses a default formatter which can be specified with the Dirigent constructor. It doesn't provide any contextual information. The input parameters are inserted into the message in the same order as they're specified.
2. Using indexed macros: "Hello {0} {1}, how are you doing?"; When translating a message with multiple arguments the translator might have to change the order in which the arguments are. Different languages have a different order of the parameter occurrences often. Therefore it must be possible to specify the position of the parameter in the input parameter list. Keep in mind positions do start with 0 not with 1! Simple indexed parameters use the default formatter as well.
3. Using a different formatter: "Hello {name}, how are you doing?"; In this example the macro value will be generated by a formatter handling the name `name`. The formatter can do whatever it wants. To provide locale based parameter values it gets a compose context. This also contains additional information. But a formatter just formats a single input parameter.
4. Using a different formatter and an index: "Hello {0:name}, how are you doing?"; It's also possible to add an optional position to the formatter. This has the same effect as for the default macro.
5. Using a formatter with special arguments: "Date: {date:format=yyyy-MM-dd}"; A formatter can get different arguments to do the job. Every argument is split with a `:`. There are two types of different arguments. A parameter argument maps a argument name to a value like the example illustrates it. A value argument only has a value. This could be a flag.
6. Providing additional information: "Hello {0:name#name of the user:some-argument}, how are you doing?"; A label is a kind of contextual information for the localizer. This won't be available within the code and only helps the localizer to understand the meaning of the parameter. A label can be used without specifying an argument too.

The label as well as the arguments are allowed to contain any character except `:`, `}` and `\` which have to be escaped using `\`.

# Process

The Dirigent process can be started by calling one of the methods `Dirigent#compose(Context, String, Object...)` or `Dirigent#compose(String, Object...)`. The latter one will create an empty context and call the first method. The process consists of three independent steps. The first one divides the message into tokens with a Tokenizer. Here are two different types. Text tokens representing static text and macros which must be processed. 
The next step converts this tokens into components. Here mainly the macros are converted into a resolved macro or an unresolved macro component. The resolved macro component represents a macro together with the formatter to use and the input parameter to format. Formatter can be registered at the Dirigent instance using `Dirigent#registerFormatter(Formatter)`. To load the correct formatter for a macro, a formatter has a method `Formatter#names` returning a set of names of a macro triggering this formatter. Additionally the `Formatter#isApplicable(Object)` method is used to check whether the formatter is able to handle the type of the message input parameter to format. If a macro doesn't have a name, a default formatter will be used which was specified at Dirigent creation time. By default it is the `StringFormatter`, which is described below. This default formatter must handle all object types. The `Formatter#isApplicable(Object)` method is not checked at this point! A token will be converted into an unresolved macro component if a converter couldn't be found. This can have two reasons. The first reason is that there isn't any registered formatter handling the used name of the macro. The second one represents the case that there is a formatter for the macro, but it doesn't handle the actual type of the message input parameter. Both reasons are represented with a `MacroResolutionState` having one of the values `UNKNOWN_NAME` or `NONE_APPLICABLE`. After converting a token to a component, the registered `PostProcessor`s of the `Dirigent` instance will be called. They're allowed to manipulate the components. More about it can be found in the PostProcessor section of this documentation. All the components will be grouped in a component group.
The first two steps are done by the `AbstractDirigent` implementation. The last step is only triggered by it and must be implemented in a sub class. Here the components must be composed to the actual message. The Dirigent framework provides the `BuilderDirigent` implementation using a `MessageBuilder` to compose the final message. This builder has two generic types. The type of the actual message and the type of the builder to use. The `StringMessageBuilder` composes `String` messages using a `StringBuilder`. The components of a component group will be loaded and processed individually. The text of Text components are appended without any modification. Resolved macro components are converted to another component by calling the actual formatter. Unresolved macro components are appended as a `{{unresolved: <macro-name>}}` string. To change this behaviour the responsible methods can be overwritten. In the end the final message object will be returned.

# Context

what is the context, what can it be used for, where is it important?
what kind of properties are available already? Contexts class

# Formatter

explain formatter, default formatter for default macro
show abstractformatter und reflectedformatter for easy usage

You can register a Macro with multiple "type-names" for a single class or multiple or you could override the isApplicable method to do your own checks.
A Macro will accept multiple arguments separated by `:` which will be provided in the MacroContext.  
It is also possible to map arguments using `<key>=<value>`.

Example DateFormatter:

Setup:
First Create a new Dirigent and register the formatter.  
```this.dirigent = new StringBuilderDirigent()```    
```this.dirigent.registerFormatter(new DateFormatter())```  
Now the DateFormatter is ready to use, you can also specify the format to use.
```this.dirigent.compose("Today is {date:format=yyyy-MM-dd}", new Date())```  
The Dirigent will now search for any registered Formatter for "type" accepting a Date.
The DateFormatter will use format argument to create a SimpleDateFormatter with the specified format and then replace the whole macro with the formatted Date.  
   

## Available Formatters

dirigent provides a few formatters already; They all provide default macro names, but they can be changed with the constructor

### StringFormatter

explanation

flags: uppercase, lowercase
context-properties: none
default-names: blub

### NumberFormatter

explanation

- flags: integer, currency, percent
- params: format
- context-properties: LOCALE, CURRENCY
- default-names: blub

#### IntegerFormatter

starts in integer mode by default

- default-names: blub

#### CurrencyFormatter

starts in currency mode by default

- default-names: blub

#### PercentFormatter

starts in percent mode by default

- default-names: blub

### DateTimeFormatter

explanation

- flags: short, medium, long, full
- params: format, date, time
- context-properties: LOCALE, TIMEZONE
- default-names: blub

#### DateFormatter

explanation

- default-names: blub

#### TimeFormatter

explanation

- default-names: blub

### StaticTextFormatter

explanation

- args: text
- params: none
- context-properties: none
- default-names: text

# Post Processors

what is it? How can they be used? dirigent + formatter

# BuilderDirigent

composes a message with a builder

StaticBuilderDirigent

how to control components, how to handle own components from own formatter
